from nk_model import NKModel
import random
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import matplotlib
import numpy as np
import time
import sys

matplotlib.use('TkAgg')

class NKModelNetwork:
    def __init__(self, n, k, num_models, num_connections_per_model, parameters=None):
        self.n = n
        self.k = k
        if not parameters:
            self.models = [NKModel(n, k) for _ in range(num_models)]
        else:
            self.models = [NKModel(n, k, input_paths=parameters[i][0], functions=parameters[i][1]) for i in range(num_models)]        

        self.num_connections_per_model = num_connections_per_model
        self.connections = [[random.randint(0, num_models - 1) for _ in range(num_connections_per_model)] for _ in range(num_models)]
        self.shock_times = [random.randint(1, 5) for _ in range(num_models)]

    def normal_step(self):
        for model in self.models:
            model.iterate()
            
    def shock_step(self):
        for i, model in enumerate(self.models):
            if self.shock_times[i] == 0:
                if sum(model.nodes) > self.n / 2:
                    self.models[self.connections[i][0]].nodes = [model.nodes[i] for i in range(len(self.models[self.connections[i][0]].nodes))]
                self.shock_times[i] = random.randint(1, 5)
            else:
                self.shock_times[i] -= 1

    def update(self):
        self.normal_step()
        self.shock_step()

    def visualize(self):
        '''generated by claude using cursor'''
        G = nx.DiGraph()
        
        for i in range(len(self.models)):
            activation = sum(self.models[i].nodes) / self.n
            color = (1-activation, 0, activation) 
            
            G.add_node(i, color=color, 
                      shock_timer=self.shock_times[i],
                      state=str(self.models[i].nodes))

        for i, connections in enumerate(self.connections):
            for target in connections:
                G.add_edge(i, target)

        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(G)
        
        node_colors = [G.nodes[node]['color'] for node in G.nodes()]
        nx.draw_networkx_nodes(G, pos, node_color=node_colors, 
                             node_size=1000)
        
        nx.draw_networkx_edges(G, pos, edge_color='gray', 
                             arrows=True, arrowsize=20)
        
        labels = {i: f"Model {i}\nShock in: {G.nodes[i]['shock_timer']}" 
                 for i in G.nodes()}
        nx.draw_networkx_labels(G, pos, labels, font_size=8)
        
        plt.title("NK Model Network Visualization")
        plt.axis('off')
        plt.show()

    def visualize_animated(self, num_frames=50):
        '''generated by claude using cursor'''
        fig, ax = plt.subplots(figsize=(15, 10))
        
        fig.patch.set_facecolor('#FFFFFF')
        
        G = nx.DiGraph()
        
        num_models = len(self.models)
        model_pos = nx.circular_layout(range(num_models), scale=2.0)
        
        node_spacing = 0.3
        all_pos = {}
        
        last_shocked = None
        shock_counter = 0
        
        for model_idx in range(num_models):
            model_center = model_pos[model_idx]
            for node_idx in range(self.n):
                angle = 2 * np.pi * node_idx / self.n
                internal_pos = [
                    model_center[0] + node_spacing * np.cos(angle),
                    model_center[1] + node_spacing * np.sin(angle)
                ]
                all_pos[f"m{model_idx}_n{node_idx}"] = internal_pos
            all_pos[f"model_{model_idx}"] = model_center

        def update(frame):
            '''generated by claude using cursor'''
            nonlocal last_shocked, shock_counter
            ax.clear()
            G.clear()
            
        
            time.sleep(0.5)
            
            is_normal_step = frame % 2 == 0
            if is_normal_step:
                ax.set_facecolor('#F0F8FF') 
                step_type = "Normal Step"
            else:
                ax.set_facecolor('#FFF0F0')
                step_type = "Shock Step"
            
            prev_states = [list(model.nodes) for model in self.models]
            
            if is_normal_step:
                self.normal_step()
            else:
                self.shock_step()
            
            for i, (prev, curr) in enumerate(zip(prev_states, self.models)):
                if prev != list(curr.nodes):
                    last_shocked = i
                    shock_counter = 5

            for model_idx, model in enumerate(self.models):
                model_name = f"model_{model_idx}"
                                
                for node_idx in range(self.n):
                    node_name = f"m{model_idx}_n{node_idx}"
                    node_color = '#8FB0D8' if model.nodes[node_idx] == 1 else '#D88F8F'
                    
                    G.add_node(node_name, 
                             color=node_color,
                             size=200)
                    
                    for input_idx in model.input_paths[node_idx]:
                        input_name = f"m{model_idx}_n{input_idx}"
                        G.add_edge(input_name, node_name, color='#404040', weight=0.5)
                
                G.add_node(model_name, 
                          color='#E0E0E0',
                          size=1200,
                          label=f"Model {model_idx}\nShock in: {self.shock_times[model_idx]}")
                
                for target in self.connections[model_idx]:
                    G.add_edge(model_name, f"model_{target}", 
                             color='#B22222', weight=2.0)

            model_nodes = [n for n in G.nodes() if n.startswith('model_')]
            nx.draw_networkx_nodes(G, all_pos, 
                                 nodelist=model_nodes,
                                 node_color=[G.nodes[n]['color'] for n in model_nodes],
                                 node_size=[G.nodes[n]['size'] for n in model_nodes],
                                 alpha=0.2)
            
            internal_nodes = [n for n in G.nodes() if n.startswith('m') and not n.startswith('model')]
            nx.draw_networkx_nodes(G, all_pos,
                                 nodelist=internal_nodes,
                                 node_color=[G.nodes[n]['color'] for n in internal_nodes],
                                 node_size=[G.nodes[n]['size'] for n in internal_nodes])
            
            model_edges = [(u, v) for (u, v) in G.edges() if u.startswith('model_')]
            nx.draw_networkx_edges(G, all_pos,
                                 edgelist=model_edges,
                                 edge_color='#B22222',
                                 width=1.5,
                                 arrows=True,
                                 arrowsize=15,
                                 min_source_margin=10,
                                 min_target_margin=10)
            
            internal_edges = [(u, v) for (u, v) in G.edges() if not u.startswith('model_')]
            nx.draw_networkx_edges(G, all_pos,
                                 edgelist=internal_edges,
                                 edge_color='#404040',
                                 width=0.5,
                                 arrows=True,
                                 arrowsize=8,
                                 min_source_margin=10,
                                 min_target_margin=10)
            
            labels = {n: G.nodes[n]['label'] for n in model_nodes}
            nx.draw_networkx_labels(G, all_pos, labels, font_size=8)
            
            ax.set_title(f"NK Model Network - Frame {frame//2} - {step_type}", 
                        pad=20, fontsize=12, fontweight='bold')
            ax.axis('off')
            
            if shock_counter > 0:
                shock_counter -= 1

        anim = FuncAnimation(fig, update, frames=num_frames * 2, 
                           interval=750, repeat=False)
        plt.show()

if __name__ == "__main__":
    n = 10
    k = 2

    if len(sys.argv) < 2:
        print(f"usage: {sys.argv[0]} [text file with model parameters]")
        exit()

    with open(sys.argv[1], "r") as input_file:
        lines = input_file.read().split("\n")

    parameters = [eval(line) for line in lines if line.strip()]

    network = NKModelNetwork(n, k, len(parameters), 2, parameters)
    
    network.visualize_animated(num_frames=50)